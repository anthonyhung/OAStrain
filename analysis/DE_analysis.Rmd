---
title: "DE_analysis"
author: "Anthony Hung"
date: "2019-12-16"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction

```{r loading libraries and data, message=F, warning=F}
library("limma")
library("plyr")
library("edgeR")
library("dplyr")
library("tidyr")
library("ashr")
library("ggplot2")
library("cowplot")
library("VennDiagram")
library("RUVSeq")
library("topGO")

#load in filtered count data, RUVs output
filt_counts <- readRDS("data/filtered_counts.rds")
filt_counts <- filt_counts$counts
RUVsOut <- readRDS("data/RUVsOut.rds")

# load gene annotations
gene_anno <- read.delim("data/gene-annotation.txt",
                        sep = "\t")

# load in reordered sample information
sampleinfo <- readRDS("data/Sample.info.RNAseq.reordered.csv")
```

# Limma doesn't deal with technical replicates, so here I randomly sample 1 replicate for each of the 6 individualxcondition

```{r random sample}
#randomly sample 1 replicate from each set of 3 replicates
individuals <- c("18855", "18856", "19160")
treatments <- c("S", "U")

set.seed(1234)
selected_samples <- c()
for(i in c("18856", "18855")){
     for(t in treatments){
          sample_num <- base::sample(c(1:3), 1)
          selected_samples <- c(selected_samples, paste0(i, sep = "_", sample_num, sep = "_", t))
     }
}

sample_num <- base::sample(c(2:3), 1)
selected_samples <- c(selected_samples, paste0("19160", sep = "_", sample_num, sep = "_", "U"))
sample_num <- base::sample(c(1:3), 1)
selected_samples <- c(selected_samples, paste0("19160", sep = "_", sample_num, sep = "_", "S"))

selected_samples
randomly_sampled_indices <- match(selected_samples, colnames(filt_counts))

single_filt_counts <- filt_counts[,randomly_sampled_indices]
anno <- pData(RUVsOut)[randomly_sampled_indices,]
```


```{r design-matrix}
single_filt_counts <- filt_counts
anno <- pData(RUVsOut)
x <- paste0(anno$Individual, anno$treatment)

anno$LibraryPrepBatch <- factor(anno$LibraryPrepBatch, levels = c("1", "2"))
anno$Replicate <- factor(anno$Replicate, levels = c("1", "2", "3"))

design <- model.matrix(~treatment + Individual + W_1 + W_2 + RIN,
                       data = anno)
colnames(design) <- gsub("treatment", "", colnames(design))
colnames(design)
```

```{r fit-model, fig.width=8}
# Model individual as a random effect (use duplicate correlation function); treatment as a fixed effect, covariates = RUV factors
     # Because of issues with duplicateCorrelation with the number of covariates I include in the design matrix, I elect intead to include all samples (all technical replicates) and use duplicateCorrelation for technical replicates and instead include Individual as a fixed effect in the linear model
# Recommended to run both voom and duplicateCorrelation twice.
# https://support.bioconductor.org/p/59700/#67620

#TMM Normalization
y <- DGEList(single_filt_counts)
y <- calcNormFactors(y, method = "TMM")
#Voom for differential expression
v1 <- voom(y, design)
corfit1 <- duplicateCorrelation(v1, design, block = x)
corfit1$consensus.correlation
v2 <- voom(y, design, block = x, correlation = corfit1$consensus.correlation)
corfit2 <- duplicateCorrelation(v2, design, block = x)
corfit2$consensus.correlation
fit <- lmFit(v2, design, block = x,
             correlation = corfit2$consensus.correlation)
fit <- eBayes(fit)

saveRDS(v2, "output/voom_results.rds")
```


## Assess model results

```{r model-results}
get_results <- function(x, number = nrow(x$coefficients), sort.by = "none",
                        ...) {
  # x - object MArrayLM from eBayes output
  # ... - additional arguments passed to topTable
  stopifnot(class(x) == "MArrayLM")
  results <- topTable(x, number = number, sort.by = sort.by, ...)
  return(results)
}

top_treatment <- get_results(fit, coef = "Unstrain", sort.by = "B")
head(top_treatment)

results_treatment <- get_results(fit, coef = "Unstrain",
                              number = nrow(filt_counts), sort = "none")
ma_treatment <- ggplot(data.frame(Amean = fit$Amean, logFC = fit$coef[, "Unstrain"]),
                       aes(x = Amean, y = logFC)) +
  geom_point() +
  labs(x = "Average expression level", y = "Log fold change",
       title = "Treatment effect")
ma_treatment
hist_treatment <- ggplot(results_treatment, aes(x = P.Value)) +
  geom_histogram(binwidth = 0.01) +
  labs(x = "p-value", y = "Number of genes", title = "Treatment effect")
hist_treatment
```


## Explore top hits

Boxplot function.

```{r boxplot-function}
plot_gene <- function(v, g) {
  # v - An EList object containing log2 counts per million
  # g - character vector of a single gene
  stopifnot(class(v) == "EList",
            is.character(g), length(g) == 1)
  library("tidyr")
  single_gene <- v$E[g, ]
  single_gene_long <- as.data.frame(single_gene)
  colnames(single_gene_long) <- "log2cpm"
  single_gene_long$sample <- rownames(single_gene_long)
  single_gene_long <- separate(single_gene_long, col = "sample", sep = "_",
                                into = c("Individual", "Replicate", "Treatment"))
  single_gene_long$Treatment <- factor(single_gene_long$Treatment, levels = c("S", "U"))
  single_gene_long$Treatment <- revalue(single_gene_long$Treatment, c("S"="Strain", "U"="No Strain"))
  
  ggplot(single_gene_long, aes(x = Treatment, y = log2cpm, fill = Treatment)) +
       labs(title = g, x = "Treatment", y = expression("Expression level (" * log[2] * " cpm)")) + 
       geom_dotplot(binaxis = "y", stackdir = "center") + 
       stat_summary(fun.data = "mean_sdl", fun.args = list(mult=1))
  
}
```

Treatment

```{r treatment}
#rename top_treatment genes to gene symbols for easier interpretation
top_treatment_top4 <- gene_anno$external_gene_name[match(head(rownames(top_treatment), n=4), gene_anno$ensembl_gene_id)]
top_treatment_top4

p_treatment_1 <- plot_gene(v2, rownames(top_treatment)[1])
p_treatment_2 <- plot_gene(v2, rownames(top_treatment)[2]) 
p_treatment_3 <- plot_gene(v2, rownames(top_treatment)[3]) 
p_treatment_4 <- plot_gene(v2, rownames(top_treatment)[4]) 
ggsave("fig-limma-treatment-hit-1.eps", plot = p_treatment_1,
       width = 7, height = 7, units = "in")
plot_grid(p_treatment_1, p_treatment_2, p_treatment_3, p_treatment_4)
```

## Use ash for mutliple testing correction

Treatment effect.

```{r ash-treatment}
run_ash <- function(x, coef) {
  # Perform multiple testing correction with adaptive shrinkage (ASH)
  #
  # x - object MArrayLM from eBayes output
  # coef - coefficient tested by eBayes
  stopifnot(class(x) == "MArrayLM", coef %in% colnames(x$coefficients))
  result <- ash(betahat = x$coefficients[, coef],
                sebetahat = x$stdev.unscaled[, coef] * sqrt(x$s2.post),
                df = x$df.total[1])
  return(result)
}

ash_treatment <- run_ash(fit, "Unstrain")
class(ash_treatment)
names(ash_treatment)
sum(ash_treatment$result$svalue < .05)
hist(ash_treatment$result$svalue)
```

# Plots

```{r Plot Functions}
plot_ma <- function(x, qval) {
  # Create MA plot.
  #
  # x - data frame with topTable and ASH output
  #     (columns logFC, AveExpr, and qvalue)
  # qval - qvalue cutoff for calling a gene DE
  #
  stopifnot(is.data.frame(x), c("logFC", "AveExpr", "qvalue") %in% colnames(x),
            is.numeric(qval), qval <= 1, qval >= 0)
  x$highlight <- ifelse(x$qvalue < qval, "darkred", "gray75")
  x$highlight <- factor(x$highlight, levels = c("darkred", "gray75"))
  ggplot(x, aes(x = AveExpr, y = logFC, color = highlight, shape = highlight)) +
    geom_point() +
    labs(x = "Average expression level", y = "Log fold change") +
    scale_color_identity(drop = FALSE) +
    scale_shape_manual(values = c(16, 1), drop = FALSE) +
    theme(legend.position = "none")
#   scale_color_gradient(low = "red", high = "white", limits = c(0, 0.25))
}

plot_volcano <- function(x, qval) {
  # Create volcano plot.
  #
  # x - data frame with topTable and ASH output
  #     (columns logFC, P.Value, and qvalue)
  # qval - qvalue cutoff for calling a gene DE
  #
  stopifnot(is.data.frame(x), c("logFC", "P.Value", "qvalue") %in% colnames(x),
            is.numeric(qval), qval <= 1, qval >= 0)
  x$highlight <- ifelse(x$qvalue < qval, "darkred", "gray75")
  x$highlight <- factor(x$highlight, levels = c("darkred", "gray75"))
  ggplot(x, aes(x = logFC, y = -log10(P.Value), color = highlight)) +
    geom_point(shape = 1) +
    labs(x = "Log fold change",
         y = expression(-log[10] * " p-value")) +
    scale_color_identity(drop = FALSE) +
    theme(legend.position = "none")
}

plot_pval_hist <- function(x, qval) {
  # Create histogram of p-values.
  #
  # x - data frame with topTable and ash output (columns P.Value and qvalue)
  # qval - qvalue cutoff for calling a gene DE
  #
  stopifnot(is.data.frame(x), c("P.Value", "qvalue") %in% colnames(x))
  x$highlight <- ifelse(x$qvalue < qval, "darkred", "gray75")
  x$highlight <- factor(x$highlight, levels = c("darkred", "gray75"))
  ggplot(x, aes(x = P.Value, fill = highlight)) +
    geom_histogram(position = "stack", binwidth = 0.01) +
    scale_fill_identity(drop = FALSE) +
    labs(x = "p-value", y = "Number of genes")
}
```

```{r use Functions}
tests <- colnames(fit$coefficients)
results <- vector(length = length(tests), mode = "list")
names(results) <- tests

for (test in tests) {
  # Extract limma results
  results[[test]] <- get_results(fit, coef = test)
  # Add mutliple testing correction with ASH
  output_ash <- run_ash(fit, coef = test)$result
  results[[test]] <- cbind(results[[test]], lfsr = output_ash$lfsr,
                           lfdr = output_ash$lfdr, qvalue = output_ash$qvalue,
                           svalue = output_ash$svalue)
}

#FDR 0.1
plot_ma(results[["Unstrain"]], 0.1)
plot_volcano(results[["Unstrain"]], 0.1)
plot_pval_hist(results[["Unstrain"]], 0.1)
table(results[["Unstrain"]]$qvalue < 0.1)
significant_genes_10 <- row.names(results[["Unstrain"]])[results[["Unstrain"]]$qvalue < 0.1]
significant_symbols_10 <- gene_anno$external_gene_name[match(significant_genes_10, gene_anno$ensembl_gene_id)]
head(significant_symbols_10)
significant_anno_10 <- gene_anno[match(significant_genes_10, gene_anno$ensembl_gene_id),]


#FDR 0.05
plot_ma(results[["Unstrain"]], 0.05)
plot_volcano(results[["Unstrain"]], 0.05)
plot_pval_hist(results[["Unstrain"]], 0.05)
table(results[["Unstrain"]]$qvalue < 0.05)
significant_genes_05 <- row.names(results[["Unstrain"]])[results[["Unstrain"]]$qvalue < 0.05]
significant_symbols_05 <- gene_anno$external_gene_name[match(significant_genes_05, gene_anno$ensembl_gene_id)]
head(significant_symbols_05)
significant_anno_05 <- gene_anno[match(significant_genes_05, gene_anno$ensembl_gene_id),]
save(significant_genes_05, file="data/DEgenes_FDR05.rda")

#FDR 0.01
plot_ma(results[["Unstrain"]], 0.01)
plot_volcano(results[["Unstrain"]], 0.01)
plot_pval_hist(results[["Unstrain"]], 0.01)
table(results[["Unstrain"]]$qvalue < 0.01)
significant_genes_01 <- row.names(results[["Unstrain"]])[results[["Unstrain"]]$qvalue < 0.01]
significant_symbols_01 <- gene_anno$external_gene_name[match(significant_genes_01, gene_anno$ensembl_gene_id)]
head(significant_symbols_01)
significant_anno_01 <- gene_anno[match(significant_genes_01, gene_anno$ensembl_gene_id),]
```

## Examining top Differentially expressed genes (FDR 0.05)

```{r DE genes analysis}
#abs(logFC) > 1
significant_genes_05_FC1 <- row.names(results[["Unstrain"]])[results[["Unstrain"]]$qvalue < 0.05 & abs(results[["Unstrain"]]$logFC) > 1]
significant_symbols_05_FC1 <- gene_anno$external_gene_name[match(significant_genes_05_FC1, gene_anno$ensembl_gene_id)]
significant_anno_05_FC1 <- gene_anno[match(significant_genes_05_FC1, gene_anno$ensembl_gene_id),]

significant_anno_05_FC1


#separate into up and downregulated
# upregulated
#logFC > 1
significant_genes_05_FC1_up <- row.names(results[["Unstrain"]])[results[["Unstrain"]]$qvalue < 0.05 & results[["Unstrain"]]$logFC > 1]
significant_symbols_05_FC1_up <- gene_anno$external_gene_name[match(significant_genes_05_FC1_up, gene_anno$ensembl_gene_id)]
significant_anno_05_FC1_up <- gene_anno[match(significant_genes_05_FC1_up, gene_anno$ensembl_gene_id),]

significant_anno_05_FC1_up

# downregulated
#logFC < -1
significant_genes_05_FC1_down <- row.names(results[["Unstrain"]])[results[["Unstrain"]]$qvalue < 0.05 & results[["Unstrain"]]$logFC < -1]
significant_symbols_05_FC1_down <- gene_anno$external_gene_name[match(significant_genes_05_FC1_down, gene_anno$ensembl_gene_id)]
significant_anno_05_FC1_down <- gene_anno[match(significant_genes_05_FC1_down, gene_anno$ensembl_gene_id),]

significant_anno_05_FC1_down
```

# boxplot of expression levels of the top DE genes separated by individual x treatment

```{r}
plot_gene <- function(v, g) {
  # v - An EList object containing log2 counts per million
  # g - character vector of a single gene
  stopifnot(class(v) == "EList",
            is.character(g), length(g) == 1)
  library("tidyr")
  single_gene <- v$E[g, ]
  single_gene_long <- as.data.frame(single_gene)
  colnames(single_gene_long) <- "log2cpm"
  single_gene_long$sample <- rownames(single_gene_long)
  single_gene_long <- separate(single_gene_long, col = "sample", sep = "_",
                                into = c("Individual", "Replicate", "Treatment"))

  single_gene_long$Treatment <- gsub('S', 'Strain', single_gene_long$Treatment)
  single_gene_long$Treatment <- gsub('U', 'Control', single_gene_long$Treatment)
  single_gene_long$Treatment <- factor(single_gene_long$Treatment, levels(factor(single_gene_long$Treatment))[c(1,2)])
  
  return(ggplot(single_gene_long, aes(x = Individual, y = log2cpm, fill = Individual)) +
              labs(title = g, y = expression("Expression level (" * log[2] * " cpm)")) + 
              geom_dotplot(binaxis = "y", stackdir = "center", key_glyph = 'rect', dotsize = 0.75) + 
              facet_wrap(~Treatment, strip.position = 'bottom') + 
              stat_summary(fun.data = "mean_sdl", fun.args = list(mult=1)) +
              theme(axis.title.x=element_blank())
              )
}

#all top genes
for (gene in 1:length(significant_anno_05_FC1[,1])) {
     print(plot_gene(v2, as.character(significant_anno_05_FC1[gene,1])))
}
#SOX9
plot_gene(v2, "ENSG00000125398")




#all top upregulated

for (gene in 1:length(significant_anno_05_FC1_up[,1])) {
     print(plot_gene(v2, as.character(significant_anno_05_FC1_up[gene,1])))
}

#all top downregulated

for (gene in 1:length(significant_anno_05_FC1_down[,1])) {
     print(plot_gene(v2, as.character(significant_anno_05_FC1_down[gene,1])))
}

```



## Gene ontology analysis with topGO

Use topGO for GO analysis.
It accounts for the nested graph structure of GO terms to prune the number of GO categories tested ([Alexa et al. 2006][Alexa2006]).
Essentially, it decreases the redundancy of the results.

[Alexa2006]: http://www.ncbi.nlm.nih.gov/pubmed/16606683

First create the gene universe.
This is all the genes tested for differential expression assigned a 1 for differentially expressed and 0 if not.

```{r gene-universe}
saveRDS(results, "data/DE_results.rds")
threshold <- 0.05
gene_universe <- as.numeric(results[["Unstrain"]]$qvalue < threshold)
gene_universe <- factor(gene_universe)
names(gene_universe) <- rownames(results[["Unstrain"]])
head(gene_universe)
```

Create the topGO data object.
Only consider "Biological Process" categories and use the Mouse Ensembl database for annotation.

```{r go-data}
go_data <- new("topGOdata",
               ontology = "BP",
               allGenes = gene_universe,
               nodeSize = 5,
               annotationFun = annFUN.org,
               mapping = "org.Hs.eg.db",
               ID = "ensembl")
```

Use the weight01 algorithm and score the tests with Fisher's exact test.

```{r go-test}
go_test <- runTest(go_data, algorithm = "weight01", statistic = "fisher")
```

Keep the results with a Fisher's exact test p-value < 0.01.

```{r go-table}
go_table <- GenTable(go_data, weightFisher = go_test,
                     orderBy = "weightFisher", ranksOf = "weightFisher",
                     topNodes = sum(score(go_test) < .01))
go_table
go_table[,-1]
```






## Gene ontology analysis with topGO (separate up and downregulated genes)

Use topGO for GO analysis.
Essentially, it decreases the redundancy of the results.


First create the gene universe for upregulated genes
This is all the genes tested for differential expression assigned a 1 for differentially expressed and 0 if not.

```{r gene-universe-up}
threshold <- 0.05
gene_universe_up <- as.numeric(results[["Unstrain"]]$qvalue < threshold & results[["Unstrain"]]$logFC > 0)
gene_universe_up <- factor(gene_universe_up)
names(gene_universe_up) <- rownames(results[["Unstrain"]])
head(gene_universe_up)
```

Create the topGO data object.
Only consider "Biological Process" categories and use the Mouse Ensembl database for annotation.

```{r go-data-up}
go_data <- new("topGOdata",
               ontology = "BP",
               allGenes = gene_universe_up,
               nodeSize = 5,
               annotationFun = annFUN.org,
               mapping = "org.Hs.eg.db",
               ID = "ensembl")
```

Use the weight01 algorithm and score the tests with Fisher's exact test.

```{r go-test-up}
go_test <- runTest(go_data, algorithm = "weight01", statistic = "fisher")
```

Keep the results with a Fisher's exact test p-value < 0.01.

```{r go-table-up}
go_table <- GenTable(go_data, weightFisher = go_test,
                     orderBy = "weightFisher", ranksOf = "weightFisher",
                     topNodes = sum(score(go_test) < .01))
go_table
go_table[,-1]
```






First create the gene universe for downregulated genes
This is all the genes tested for differential expression assigned a 1 for differentially expressed and 0 if not.

```{r gene-universe-down}
threshold <- 0.05
gene_universe_down <- as.numeric(results[["Unstrain"]]$qvalue < threshold & results[["Unstrain"]]$logFC < 0)
gene_universe_down <- factor(gene_universe_down)
names(gene_universe_down) <- rownames(results[["Unstrain"]])
head(gene_universe_down)
```

Create the topGO data object.
Only consider "Biological Process" categories and use the Mouse Ensembl database for annotation.

```{r go-data-down}
go_data <- new("topGOdata",
               ontology = "BP",
               allGenes = gene_universe_down,
               nodeSize = 5,
               annotationFun = annFUN.org,
               mapping = "org.Hs.eg.db",
               ID = "ensembl")
```

Use the weight01 algorithm and score the tests with Fisher's exact test.

```{r go-test-down}
go_test <- runTest(go_data, algorithm = "weight01", statistic = "fisher")
```

Keep the results with a Fisher's exact test p-value < 0.01.

```{r go-table-down}
go_table <- GenTable(go_data, weightFisher = go_test,
                     orderBy = "weightFisher", ranksOf = "weightFisher",
                     topNodes = sum(score(go_test) < .01))
go_table
go_table[,-1]
```






# Perform DE analysis using edgeR

```{r edgeR}
#Subset RUVsOut for only one of each of the samples (no technical replicates)
RUVsSubset <- RUVsOut[, RUVsOut$Sample_ID %in% selected_samples]


design <- model.matrix(~treatment + W_1 + W_2 + RIN, data=pData(RUVsSubset))
y <- DGEList(counts=counts(RUVsSubset), group=pData(RUVsSubset)$Individual)
y <- calcNormFactors(y, method="upperquartile")
y <- estimateGLMCommonDisp(y, design)
y <- estimateGLMTagwiseDisp(y, design)
fit <- glmFit(y, design)
lrt <- glmLRT(fit, coef=2)
gene_values <- topTags(lrt, n = nrow(lrt$coefficients), adjust.method="BH", sort.by = "PValue")
```

## Explore top hits


```{r plot functions}
plot_gene <- function(v, g) {
  # v - An df containing log2 counts per million
  # g - character vector of a single gene
  library("tidyr")
  single_gene <- v[g, ]
  single_gene_long <- as.data.frame(single_gene)
  colnames(single_gene_long) <- "log2cpm"
  single_gene_long$sample <- rownames(single_gene_long)
  single_gene_long <- separate(single_gene_long, col = "sample", sep = "_",
                                into = c("Individual", "Replicate", "Treatment"))
  single_gene_long$Treatment <- factor(single_gene_long$Treatment, levels = c("S", "U"))
  single_gene_long$Treatment <- revalue(single_gene_long$Treatment, c("S"="Strain", "U"="No Strain"))

  ggplot(single_gene_long, aes(x = Treatment, y = log2cpm, fill = Treatment)) +
       labs(title = g, x = "Treatment", y = expression("Expression level (" * log[2] * " cpm)")) + 
       geom_dotplot(binaxis = "y", stackdir = "center") + 
       stat_summary(fun.data = "mean_sdl", fun.args = list(mult=1))

}

plot_volcano <- function(x, qval) {
  # Create volcano plot.
  #
  # x - data frame with topTable output
  #     (columns logFC, PValue, and FDR)
  # qval - qvalue cutoff for calling a gene DE
  #
  stopifnot(is.data.frame(x), c("logFC", "PValue", "FDR") %in% colnames(x),
            is.numeric(qval), qval <= 1, qval >= 0)
  x$highlight <- ifelse(x$FDR < qval, "darkred", "gray75")
  x$highlight <- factor(x$highlight, levels = c("darkred", "gray75"))
  ggplot(x, aes(x = logFC, y = -log10(PValue), color = highlight)) +
    geom_point(shape = 1) +
    labs(x = "Log fold change",
         y = expression(-log[10] * " p-value")) +
    scale_color_identity(drop = FALSE) +
    theme(legend.position = "none")
}

plot_pval_hist <- function(x, qval) {
  # Create histogram of p-values.
  #
  # x - data frame with topTable and ash output (columns P.Value and qvalue)
  # qval - qvalue cutoff for calling a gene DE
  #
  stopifnot(is.data.frame(x), c("PValue", "FDR") %in% colnames(x))
  x$highlight <- ifelse(x$FDR < qval, "darkred", "gray75")
  x$highlight <- factor(x$highlight, levels = c("darkred", "gray75"))
  ggplot(x, aes(x = PValue, fill = highlight)) +
    geom_histogram(position = "stack", binwidth = 0.01) +
    scale_fill_identity(drop = FALSE) +
    labs(x = "p-value", y = "Number of genes")
}

```


## Box plots of top genes

```{r boxplots}
cpm <- cpm(filt_counts, log = T)

# top genes by p-value

#rename top_treatment genes to gene symbols for easier interpretation
top_treatment_top10 <- gene_anno$external_gene_name[match(head(rownames(gene_values@.Data[[1]]), n=10), gene_anno$ensembl_gene_id)]
top_treatment_top10

p_treatment_1 <- plot_gene(cpm, rownames(gene_values@.Data[[1]])[1])
p_treatment_2 <- plot_gene(cpm, rownames(gene_values@.Data[[1]])[2]) 
p_treatment_3 <- plot_gene(cpm, rownames(gene_values@.Data[[1]])[3]) 
p_treatment_4 <- plot_gene(cpm, rownames(gene_values@.Data[[1]])[4]) 
ggsave("fig-limma-treatment-hit-1.eps", plot = p_treatment_1,
       width = 7, height = 7, units = "in")
plot_grid(p_treatment_1, p_treatment_2, p_treatment_3, p_treatment_4)


```


## Plots with significant genes highlighted

```{r use plotting functions}
thresh <- 0.01
plot_volcano(x=data.frame(gene_values@.Data[[1]]), thresh)
plot_pval_hist(x=data.frame(gene_values@.Data[[1]]), thresh)
table(gene_values@.Data[[1]]$FDR < thresh)
```



## Gene ontology analysis with topGO

Use topGO for GO analysis.
Essentially, it decreases the redundancy of the results.

First create the gene universe.
This is all the genes tested for differential expression assigned a 1 for differentially expressed and 0 if not.

```{r gene-universe1}
threshold <- 0.01
gene_universe <- as.numeric(gene_values@.Data[[1]]$FDR < threshold)
gene_universe <- factor(gene_universe)
names(gene_universe) <- rownames(gene_values@.Data[[1]])
head(gene_universe)
```

Create the topGO data object.
Only consider "Biological Process" categories and use the Mouse Ensembl database for annotation.

```{r go-data1}
go_data <- new("topGOdata",
               ontology = "BP",
               allGenes = gene_universe,
               nodeSize = 5,
               annotationFun = annFUN.org,
               mapping = "org.Hs.eg.db",
               ID = "ensembl")
```

Use the weight01 algorithm and score the tests with Fisher's exact test.

```{r go-test1}
go_test <- runTest(go_data, algorithm = "weight01", statistic = "fisher")
```

Keep the results with a Fisher's exact test p-value < 0.01.

```{r go-table1}
go_table <- GenTable(go_data, weightFisher = go_test,
                     orderBy = "weightFisher", ranksOf = "weightFisher",
                     topNodes = sum(score(go_test) < .01))
go_table
go_table[,-1]
```

There are `r nrow(go_table)` significant results.











<!-- # Looking at treatment x individual interactions -->

<!-- ```{r design-matrix_interaction} -->
<!-- design2 <- model.matrix(~treatment + Individual + treatment:Individual + W_1 + W_2 + RIN, -->
<!--                        data = anno) -->
<!-- colnames(design2) -->
<!-- ``` -->

<!-- ```{r fit-model, fig.width=8} -->
<!-- #TMM Normalization -->
<!-- y <- DGEList(single_filt_counts) -->
<!-- y <- calcNormFactors(y, method = "TMM") -->
<!-- anno <- pData(RUVsOut) -->
<!-- x <- paste0(anno$Individual, anno$treatment) -->
<!-- #Voom for differential expression -->
<!-- v1_interaction <- voom(y, design2) -->
<!-- corfit1_interaction <- duplicateCorrelation(v1_interaction, design2, block = x) -->
<!-- corfit1_interaction$consensus.correlation -->
<!-- v2_interaction <- voom(y, design2, block = x, correlation = corfit1_interaction$consensus.correlation) -->
<!-- corfit2_interaction <- duplicateCorrelation(v2_interaction, design2, block = x) -->
<!-- corfit2_interaction$consensus.correlation -->
<!-- fit_interaction <- lmFit(v2_interaction, design2, block = x, -->
<!--              correlation = corfit2_interaction$consensus.correlation) -->
<!-- fit_interaction <- eBayes(fit_interaction) -->
<!-- ``` -->


<!-- ## Assess model results -->

<!-- ```{r model-results-interaction} -->
<!-- tests_interaction <- colnames(fit_interaction$coefficients) -->
<!-- results_interaction <- vector(length = length(tests_interaction), mode = "list") -->
<!-- names(results_interaction) <- tests_interaction -->

<!-- for (test in tests_interaction) { -->
<!--   # Extract limma results -->
<!--   results_interaction[[test]] <- get_results(fit_interaction, coef = test) -->
<!--   # Add mutliple testing correction with ASH -->
<!--   output_ash <- run_ash(fit_interaction, coef = test)$result -->
<!--   results_interaction[[test]] <- cbind(results_interaction[[test]], lfsr = output_ash$lfsr, -->
<!--                            lfdr = output_ash$lfdr, qvalue = output_ash$qvalue, -->
<!--                            svalue = output_ash$svalue) -->
<!-- } -->


<!-- #FDR 0.05 -->
<!-- #interaction term 1 -->
<!-- plot_ma(results_interaction[["treatmentUnstrain:IndividualNA18856 "]], 0.05) -->
<!-- plot_volcano(results_interaction[["treatmentUnstrain:IndividualNA18856 "]], 0.05) -->
<!-- plot_pval_hist(results_interaction[["treatmentUnstrain:IndividualNA18856 "]], 0.05) -->
<!-- table(results_interaction[["treatmentUnstrain:IndividualNA18856 "]]$qvalue < 0.05) -->
<!-- significant_genes_05 <- row.names(results_interaction[["treatmentUnstrain:IndividualNA18856 "]])[results_interaction[["treatmentUnstrain:IndividualNA18856 "]]$qvalue < 0.05] -->
<!-- significant_symbols_05 <- gene_anno$external_gene_name[match(significant_genes_05, gene_anno$ensembl_gene_id)] -->
<!-- head(significant_symbols_05) -->
<!-- significant_anno_05 <- gene_anno[match(significant_genes_05, gene_anno$ensembl_gene_id),] -->

<!-- #interaction term 2 -->
<!-- plot_ma(results_interaction[["treatmentUnstrain:IndividualNA19160 "]], 0.05) -->
<!-- plot_volcano(results_interaction[["treatmentUnstrain:IndividualNA19160 "]], 0.05) -->
<!-- plot_pval_hist(results_interaction[["treatmentUnstrain:IndividualNA19160 "]], 0.05) -->
<!-- table(results_interaction[["treatmentUnstrain:IndividualNA19160 "]]$qvalue < 0.05) -->
<!-- significant_genes_05 <- row.names(results_interaction[["treatmentUnstrain:IndividualNA19160 "]])[results_interaction[["treatmentUnstrain:IndividualNA19160 "]]$qvalue < 0.05] -->
<!-- significant_symbols_05 <- gene_anno$external_gene_name[match(significant_genes_05, gene_anno$ensembl_gene_id)] -->
<!-- head(significant_symbols_05) -->
<!-- significant_anno_05 <- gene_anno[match(significant_genes_05, gene_anno$ensembl_gene_id),] -->
<!-- ``` -->


# Volcano plots broken down by individual

```{r individual volcano plots}
single_filt_counts <- filt_counts
anno <- pData(RUVsOut)

NA18855_index <- which(anno$Individual == "NA18855 ")
NA18855 <- single_filt_counts[, NA18855_index]
NA18855_anno <- anno[NA18855_index, ]
     
NA18856_index <- which(anno$Individual == "NA18856 ")
NA18856 <- single_filt_counts[, NA18856_index]
NA18856_anno <- anno[NA18856_index, ]
     
NA19160_index <- which(anno$Individual == "NA19160 ")
NA19160 <- single_filt_counts[, NA19160_index]
NA19160_anno <- anno[NA19160_index, ]


plot_volcano <- function(x, qval) {
  # Create volcano plot.
  #
  # x - data frame with topTable and ASH output
  #     (columns logFC, P.Value, and qvalue)
  # qval - qvalue cutoff for calling a gene DE
  #
  stopifnot(is.data.frame(x), c("logFC", "P.Value", "qvalue") %in% colnames(x),
            is.numeric(qval), qval <= 1, qval >= 0)
  x$highlight <- ifelse(x$qvalue < qval, "darkred", "gray75")
  x$highlight <- factor(x$highlight, levels = c("darkred", "gray75"))
  ggplot(x, aes(x = logFC, y = -log10(P.Value), color = highlight)) +
    geom_point(shape = 1) +
    labs(x = "Log fold change",
         y = expression(-log[10] * " p-value")) +
    scale_color_identity(drop = FALSE) +
    theme(legend.position = "none")
}

volcano_plot_ind <- function(annotation, filtered_counts){
     design <- model.matrix(~treatment + W_1 + W_2 + RIN,
                            data = annotation)
     colnames(design) <- gsub("treatment", "", colnames(design))
     
     #TMM Normalization
     y <- DGEList(filtered_counts)
     y <- calcNormFactors(y, method = "TMM")
     #Voom for differential expression
     v1 <- voom(y, design)
     fit <- lmFit(v1, design, block = annotation$treatment,
                  correlation = corfit2$consensus.correlation)
     fit <- eBayes(fit)
     
     #extract results and run ash
     tests <- colnames(fit$coefficients)
     results <- vector(length = length(tests), mode = "list")
     names(results) <- tests
     
     for (test in tests) {
          # Extract limma results
          results[[test]] <- get_results(fit, coef = test)
          # Add mutliple testing correction with ASH
          output_ash <- run_ash(fit, coef = test)$result
          results[[test]] <- cbind(results[[test]], lfsr = output_ash$lfsr,
                                   lfdr = output_ash$lfdr, qvalue = output_ash$qvalue,
                                   svalue = output_ash$svalue)
          }

     #FDR 0.05
     print(plot_volcano(results[["Unstrain"]], 0.05))
     
     print(table(results[["Unstrain"]]$logFC > 0))
}


#make plots
volcano_plot_ind(NA18855_anno, NA18855)
volcano_plot_ind(NA18856_anno, NA18856)
#volcano_plot_ind(NA19160_anno, NA19160)

#19160
design <- model.matrix(~treatment + W_1 + W_2,
                            data = NA19160_anno)
colnames(design) <- gsub("treatment", "", colnames(design))
     
#TMM Normalization
y <- DGEList(NA19160)
y <- calcNormFactors(y, method = "TMM")
#Voom for differential expression
v1 <- voom(y, design)
fit <- lmFit(v1, design, block = NA19160_anno$treatment,
                  correlation = corfit2$consensus.correlation)
fit <- eBayes(fit)
     
#extract results and run ash
tests <- colnames(fit$coefficients)
results <- vector(length = length(tests), mode = "list")
names(results) <- tests
     
for (test in tests) {
     # Extract limma results
     results[[test]] <- get_results(fit, coef = test)
     # Add mutliple testing correction with ASH
     output_ash <- run_ash(fit, coef = test)$result
     results[[test]] <- cbind(results[[test]], lfsr = output_ash$lfsr,
                              lfdr = output_ash$lfdr, qvalue = output_ash$qvalue,
                              svalue = output_ash$svalue)
     }

#FDR 0.05
plot_volcano(results[["Unstrain"]], 0.05)

table(results[["Unstrain"]]$logFC > 0)

```


